'''
# 2_그리디(탐욕알고리즘)

탐욕알고리즘 : 현재선택할 수 있는 것들 중에서 가장 최선의 선택만을 반복하는 알고리즘 

탐욕 알고리즘 사용하는 경우

1. 입력크기가 너무 커서 완전탐색이 불가능할 경우
2. 현실적으로 모든 경우의수를 짚는 것이 어려울 때 

그리디 속성 

1. 탐욕적 선택 속성 : 한 번 선택한 결과는 다음 선택에 어떠한 영향도 미치지 않아야 함, 각 단계마다 최선의 선택이 이루어지면 그걸로 끝이니까 이전 결과를 들여다 볼 필요가 없음
2. 최적 부분 구조 
    - 동적프로그래밍 : 작은 문제가 주여졌을 때 특정 계산법을 사용해서 최적의 정답을 이끌어내는 원리를 큰 문제에서도 활용하는 것
    - 그리디 : 작은문제든 큰 문제든 항상 일관적으로 최선의 경우만을 선택해서 최적의 정답을 이끌어냄

완전탐색 vs 그리디 판단방법 


ex) 동전문제 - 판단기준 : 주어진 동전 단위

그리디 : 거의 배수 구조 , 큰거부터 써도 손해없음 / [키워드 : 최대,최소+정렬, 가장 큰 것 부터, 한번에 선택, 되도록 많이 사용]

dp : 배수구조 아닐 때, 중간값이 애매할 때  / [키워드 : 최소개수, 경우의 수,만드는 방법의 수, 모든 경우를 고려]


'''


'''
문제 조건 
숫자 최대길이가 1,000,000 
앞자리 클수록 무조건 전체 숫자 커짐 -> 왼쪽부터 최대한 크게 만드는게 최우선목표 
>> 현재 앞자리를 키우는 선택은 미래에 손해가 되지 않음 
>>> 그리디 


'''
def solution(number, k):
    answer = []
    for num in number:
        while True:
            # 1 더 이상 지울 수 없으면 종료
            if k == 0:
                break
            # 2 아직 아무 숫자도 없으면 종료
            if not answer:
                break
            # 3 이전 숫자가 현재 숫자보다 크거나 같으면 유지
            if answer[-1] >= num:
                break
            # 4 여기까지 왔다는 건: 버리는 게 이득
            answer.pop()
            k -= 1

        answer.append(num)

    return ''.join(answer[:len(answer) - k])

'''
같은 코드 
while k > 0 and answer and answer[-1] < num:
    answer.pop()
    k -= 1

'''